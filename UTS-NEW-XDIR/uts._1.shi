# /bin/bash

# clone candidates.
# null errecho (fnecho ...) errifnull callFnIfExists exiterr -k exitok fnname no ne getarg isNum
# tmpFile _sys.evalerr isTerminalOutput setcol append (?) io.no io.ne io.none win.clear win.curpos

# LEVEL 0 FNS
# purely for uts debugging.

. uts.uts.shi 

dbg "INCLUDE: START uts._1"

if uts.isincluded ${BASH_SOURCE[0]} ; then 
	dbg "RETURNING AS ALREADY INCLUDED <${BASH_SOURCE[0]}>";
	return 1;
fi

dbg "INCLUDE: PAST REINCLUDE TEST: uts._1"
dbg "INCLUDE: REINCLUDE SELF ... "

. uts._1.shi

dbg "INCLUDE POST INCLUDE SELF ... ERROR IF THIS APPEARS TWICE"

nb:()	{ :; }
tbd:()	{ :; }
tbc:()	{ :; }

__UTS_ECHO_INTERCEPT=false;

if $__UTS_ECHO_INTERCEPT; then

	__REALECHO=$(which echo);

	echo() 
	{
		if test "$1" = '--real'; then
			shift;
			$__REALECHO "$@";
			return 0;
		fi
		_io.echo "$@";
	}

fi

_sys.code()	  { base64 - <<< "$@"; }
_sys.decode() { base64 -d - <<< "$@"; }
_sys.eval()	  { eval "$@"; }
_sys.fnname() { local level=${1:-1};  _io.echo ${FUNCNAME[$level]}; }
_io.echo()	  { echo $*; }
_io.err()	  { echo $* >&2; }
_sys.kill()	  { kill 0; }

_sys.abort()
{
	_io.err "
		$(_sys.fnname): likely programming error.
		Error message: $*
		Aborting - have a nice day!
	";
	_sys.kill
}

_fn.return()	  { local retval=$1; shift; _io.echo "_sys.eval _io.echo $* && return $retval"; }


_io.no()	  { "$@" >/dev/null; }
_io.ne()	  { "$@" 2>/dev/null; }
_io.none()	  { "$@" >/dev/null 2>/dev/null; }


_sys.null()	  { test -z "$@"; }
_sys.inline()	  { _sys.eval "$@"; }

_ass.notnull() { test -z "$@" && _ass.err "value(s) cannot be null"; }

_val.const()
{
	local name=$1; _ass.notnull $name;
	local value=${2:-$name}

	local tpl="
		$name() 
		{
			$(_fn.return 0 $value);
		}
	"
	_sys.inline $tpl;
}

_val.const _ass.stacksz 5;

_sys.stack()  
{
	local ss=$(_ass.stacksz);
	local n=${1:-$ss}

	local res=""
	for ((i=2; i<$n; i++)); do 
		res="$FUNCNAME[$i] "' '"$res";
	done; 
	$(_fn.return 0 $res);
}

_ass.err() 
{ 
	local ssz=$(_ass.stacksz);

	_sys.abort "
		Assertion error [$@].
		Cannot continue.

		Call stack [max <$ssz> fns shown]: [$(_sys.stack)].
	";
}

_var.declared()
{
	local var=$1; _ass.notnull $var;
	_io.none declare -p $var
}

_var.env()
{
	local envname=$1;
	_ass.notnull $envname;

	local -n refenv=$1; 
	local value=${2:-""};

	if ! _var.declared $refenv; then
		nb: declare global readonly var.
		declare -r $envname=$value;
	else 
		nb: envvar is declared, assign default value if null.
		refenv=${refenv:-$value};
	fi
}

#_val.const Debug true;

#$(_sys.Debug) ## dbg()
#{
#	$(_sys.Debug) ## _io.err "<${FUNCNAME[2]}>,<${FUNCNAME[1]}>: $@";
#}

## basic sys stuff.

_ass.nothere()
{
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]};

    _sys.abort "$fn (called by $fncaller): assertion violation due to executing 'unreachable code'";
}

_regexp.subst()
{
	local pattern=$1; _ass.notnull $pattern;
	shift;

	local values="$@";
	sed "s/$pattern//g" <<< $values;
}

_regexp.match()
{
	local pattern=$1; _ass.notnull $pattern;
	local value=$2; _ass.notnull $value;

	local sedvalue=$(_regexp.subst $pattern $value);
	! test "$value" = "$sedvalue";
}

false && _regexp.haswhite()
{
	local input=$1
}

_ass.nowhite()
{
	local count=0;
	local fn=${FUNCNAME[1]};
	local fncaller=${FUNCNAME[2]}:

	for i in "$@"; do 
		count=$((count+1));
		if _regexp.match ' ' $i || _regexp.match '\t' $i; then
			_sys.abort "
				<$fn> [called by: <$fncaller>]: assertion error - whitespace detected - value:<$i>.
				[NB: this is argument \$<$count> to function:<$fn> and likely to calling function:<$fncaller>].

			";

		fi 
	done
	return 0;
}

_ass.notnull.mutually.exclusive()
{
	_ass.nowhite "$@";

	local testvar=$1;
	local rest=$*;
}

_sys.strict() # [--on|--off]
{
	local flag=${1:-'--on'};

	if test --on = "$flag"; then
		set -u;
		return;
	elif test --off = "$flag"; then
		set +u;
		return;
	elif test $# = '0'; then
		set -u;
		return;
	fi
	_sys.abort "${FUNCNAME[1]}: unknown argument error <$@>";
}
_sys.strict --on;
_sys.strict --off
_sys.strict --on;
_sys.strict

_sys.exit()
{
    local exitval=${1:-0};
    exit $exitval;
}

### IO basics
_io.echo() { _io.echo $*; }

_io.err() # [--abort]
{
    local abort=false;
    local flag=${1:-""};

    if test "$flag" = "--abort"; then
        abort=true;
        shift;
    fi
    echo "$@" >&2;
    $abort && _io.stack && _sys.abort;
}

### FN MANIPULATION/CREATION.
_fn.name()
{
    local level=${1:-1};

	level=$((level+1));
    _io.echo "${FUNCNAME[$level]}";
}

_io.stack()
{
    local nlevels=${1:-10}
    local res="";
    for ((i=2;i<nlevels;i++)) do
		local fnname=$(_fn.name i);
		if ! test -z "$fnname"; then
			res=$res' '$fnname;
		fi
    done
    _io.err $res;
	return 0;
}

_fn.caller()
{
    _fn.name 2;
}

#if false; then
#declare -g __valS_ERRFN="";
#_vals.errfn()
#{
#    local flag=$1;
#    
#    if test $flag == '--isnull'; then 
#        test -z $__valS_ERRFN;
#
#
#        return;
#
#    elif test $flag == '--clear'; then
#        __valS_ERRFN=$2;
#        return 0;
#
#    elif test $flag == '--set' && _vals.errfn --isnull; then
#        __valS_ERRFN=$2;
#        return 0;
#    
#    elif test $flag == '--set' && _vals.errfn --isnull; then
#        # do nothing.
#        return 0;
#
#    elif test $flag == '--get' && ! _vals.errfn --isnull; then
#        _io.echo $__valS_ERRFN;
#        return 0;
#
#    elif test $flag == '--get' && _vals.errfn --isnull; then
#        _io.err "$(_fn.name): cannot get args when fn is not set";
#        _sys.abort;
#    fi
#    
#    _io.err "$(_fn.name): unknown flag <$flag>";
#    _sys.abort;
#}
#fi
###

## std sed filters.
_regexp.rmwhite()
{
	sed 's/ //g';
}

_val()
{   
	_ass.nowhite "$@";
    local arg=$1;
    
    if test -z "$arg"; then
        local caller=$(_fn.caller);
        _sys.abort "$caller: empty arg value";
    fi

    _vals.ws "$1";
    _io.echo $1;

    _vals.errfn --clear;
}


# more advance _fn stuff.
_fn.clone()
{
    local fromfn=$(_val $1);
    local tofn=$(_val $2);

    if ! test $(type -t $fromfn) = "function"; then
        _io.err "$(_fn.name): attemps to clone non existant function <$fromfn>";
        _sys.abort;
    fi
    
    local clonebody=$(declare -f $fromfn | grep -v $fromfn);
    
    local tpl="
        $tofn()
        $clonebody
    ";

    _sys.eval $tpl
}

## null arg, ws arg, abort msgs, ...
##
##
#
#nb:() { :; }
#
#nb: below makes a difference. no err. with set -u, there is an error. 
#nb: but with below also fn.error.
#
#set +u
#
#egfn()
#{
#    local a1=$(_val $1);
#    local a2=$(_val ${2-'default'});
#
#    _io.echo $a1 $a2
#}
#
#egfn 'ws ws' hithere;
