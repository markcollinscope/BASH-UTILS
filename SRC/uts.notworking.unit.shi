#!/bin/bash

###
# NB:
# Search 'PUBLIC API' - to find the functions you use to write bash unit-tests.
# all the early code is set up related.
###

# nothing to do if no flag is supplied as first argument to this script directly, or the including script.
__BU_SRC="$0"
__BU_THISFILE="${BASH_SOURCE[0]}";

dbg()	{ echo "$0: $@"; }

if ! [[ "$1" = -* ]]; then
	dbg first arg: $1
	dbg "time to go"

	test __BU_SRC = __BU_THISFILE && return 0; # TODO test this!
	exit 0;
fi

dbg "main body"

### IMPORT FROM ENV - OR USE LOCAL DEFAULTS.
# regular expression definition - used find tests (using grep) client code needing testing.
readonly BU_REGEX=${BU_REGEX:-'^.*function.*test.*()'};

### GLOBAL CONSTS.
# self test related.
readonly BU_SELF_TEST_FLAG=${BU_SELF_TEST_FLAG:-'--self'};
readonly BU_VERBOSE_FLAG=${BU_VERBOSE_FLAG-'--selfvb'};
readonly BU_HELP_FLAG=${BU_HELP_FLAG-'--help'};

# testing bash scripts/functions realted.
readonly BU_TEST_FLAG=${BU_TEST_FLAG:-'--test'};

# TODO - Env Setup Stuff Above.

### SCRIPT GLOBAL VARS (BASH: 1 (or any non 0 value) - false, 0 - true - when returned from function).
declare -g __BU_FIRST_ARG=${1-}

### START CODE ###

_fn()
{
	local level=${1:-1};
	local fn="${FUNCNAME[$level]}"

	echo $fn
}

_bye() 
{
	_echoif "...terminating - have a wonderful day debugging!";
}

_help()
{
	>&2 echo "WRITE THE HELP SECTION!";
}


# set colors of output, push color to set,and pop to return to previous...
_rmfirst() 		{ shift; echo "$@"; }
_addfirst() 	{ echo "$@"; }
_echofirst() 	{ echo $1; }
_setcolor()  	{ local cmd="tput setaf $1"; $cmd; $cmd >&2; }

declare -g __BU_COLSTACK=7
_pushcolor() 	{ local newcolor=$1; __BU_COLSTACK=$(_addfirst $newcolor $__BU_COLSTACK); _setcolor $newcolor; }
_popcolor()		{ __BU_COLSTACK=$(_rmfirst $__BU_COLSTACK); local previous_color=$(_echofirst $__BU_COLSTACK); _setcolor $previous_color; }

_red() 			{ _pushcolor 1; }
_white() 		{ _pushcolor 7; }
_green() 		{ _pushcolor 2; }
_yellow()		{ _pushcolor 3; }
_unsetcolor()	{ _popcolor; }

# vebose output functions.
declare -g __BU_VERBOSE=1;
_setVerbose() 		{ __BU_VERBOSE=0; _vb 'verbose mode on'; }
_verbose() 			{ return $__BU_VERBOSE; }
_vb() 				{ if _verbose; then _yellow; >&2  _echoif "$@"; _unsetcolor; fi }

# use this function for echo-ing for user output - enables teh output to be switched off.
declare -g __BU_SILENT=1;
_setSilent()	{ __BU_SILENT=0; }
_silent() 		{ return $__BU_SILENT; }
_echoif()		{ if ! _silent; then echo $*; fi; }
_errif()		{ _echoif $* >&2; }

# self test related.
declare -g __BU_SELF_TEST=1;
_setSelfTest() 		{ __BU_SELF_TEST__=0; _vb 'self test mode on'; }
_inSelfTestMode() 	{ return $__BU_SELF_TEST; }

__BU_SRC=$0;

# PARSE FOR BASH UNIT RUNTIME OPTIONS
if test "$__BU_FIRST_ARG" = "$BU_SELF_TEST_FLAG"; then
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_VERBOSE_FLAG; then
	_setVerbose;
	_setSelfTest;
	shift;
elif test "$__BU_FIRST_ARG" = $BU_HELP_FLAG; then
	_errif "help:"
	_errif "-----"
	_help;
	_errif "-----"
	exit 1;
fi

#
_vb "$__BU_THISFILE: testing... use the <--help> option for more information";


# finding and running unit tests.
_callifdefined() { if test "$(type -t $1)" = "function" ; then "$@"; fi }

_findTests()
{
	local tests=$(grep "$BU_REGEX" $__BU_SRC | grep -v BU_REGEX | sed 's/().*//' | sed 's/function//'; );
    echo $tests
}

_passFailAssert()
{
	local testfn=$1;
	local ASSERTION_SUCCESS=$2;
	shift 2;

	__ASSERT_COUNT=$((__ASSERT_COUNT+1))

	if $ASSERTION_SUCCESS; then
		_green
		_vb "$testfn -- Assertion Passed ("$@")";
		__ASSERT_PASSES=$((__ASSERT_PASSES+1))
		_unsetcolor;
	else 
		_red
		_vb "$testfn -- Assertion Failed("$@")";
		__ASSERT_FAILS=$((__ASSERT_FAILS+1))
		_THIS__TEST_PASSES=false;
		_unsetcolor;
	fi
}

###### PUBLIC API - THE FOLLOWING FUNCTIONS ARE THOSE INTENDED FOR USE BY CLIENT CODE (USERS OF THIS FILE)

# IS TESTING MODE ACTIVE?
declare -g 	__BU_TEST_ACTIVE=1;
function tst.active()
{
	return $__BU_TEST_ACTIVE;
}

# ASSERT TWO VALUES ($1, $2) ARE THE SAME
function tst.assertSame()
{
	local testfn=$1;
	local val1="$2";
	local val2="$3";

	local has_passed=false;

	if test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $testfn $has_passed tst.assertSame "<$val1>" "<$val2>"
}

# ASSERT TWO VALUES ($1, $2) ARE DIFFERENT
function tst.assertDiff()
{
	local testfn=$1;
	local val1=$2;
	local val2=$3;

	local has_passed=false;
	if ! test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $testfn $has_passed tst.assertDiff "$@";
}

# WRAPPER FUNCTION FOR ASSERTS - PREFERED FUNCTION TO USE.
function tst.assert()
{
	local fn=$(_fn 4);

	if test "$1" = "--same"; then
		shift;
		tst.assertSame $fn "$@"
	
	elif test "$1" = "--diff"; then
		shift;
		tst.assertDiff $fn "$@"
	
	elif test "$1" = "--true"; then
		shift;
		tst.assertSame $fn true "$@"
	
	elif test "$1" = "--false"; then
		shift;
		tst.assertSame $fn false "$@"
	
	elif test "$1" = "--ok"; then
		shift;
		tst.assertSame $fn 0 "$@";

	elif test "$1" = "--err"; then
		shift;
		tst.assertDiff $fn 0 "$@";
	
	else
		_errif
		_errif "$__BU_SRC: no such option: $1 - testing fully aborted";
		_errif
		exit 1;
	fi
}

function tst.report()
{
	local status_message="NB: TEST FAILURE(S) FOUND";
	local pass=false;
	
	if test "$__ASSERT_FAILS" = "0"; then 
		status_message="ALL TESTS PASSED"; 
		pass=true;	
	fi

	cat <<ENDCAT

	Test Report
	-----------
	TOTAL ASSERTIONS:              $__ASSERT_COUNT
	ASSERTION_SUCCESS:             $__ASSERT_PASSES
	ASSERTION FAILURES:            $__ASSERT_FAILS
	-----------
	TOTAL TESTS:                   $__TEST_CNT
	TEST PASSES:                   $__TEST_PASSES
	TEST FAILURES:                 $__TEST_FAILS
	-----------
ENDCAT

	if $pass; then _green; else _red; fi

cat <<ENDCAT

	($status_message)

ENDCAT
	_unsetcolor;
}

declare -g __ASSERT_COUNT=0
declare -g __ASSERT_PASSES=0
declare -g __ASSERT_FAILS=0

declare -g __TEST_PASSES=0;
declare -g __TEST_FAILS=0;
declare -g __TEST_CNT=0;

function tst.run()
{
	local TESTS=$(_findTests);

	_vb
	_vb "ABOUT TO RUN THE FOLLOWING TESTS: <$TESTS>";
	_vb

	_callifdefined tst.init

	for test in $TESTS; do
		__TEST_CNT=$((__TEST_CNT+1));
		_THIS__TEST_PASSES=true;

		_vb
		_vb "TESTING FUNCTION <$test>"

		_callifdefined tst.setup
		_callifdefined $test;
		_callifdefined tst.teardown

		_vb
		if $_THIS__TEST_PASSES; then
			_green
			_vb "**** $test -- Test Passed ****";
			_vb
			_white
			__TEST_PASSES=$((__TEST_PASSES+1));
		else
			_red
			_vb "**** $test -- Test Failed ****";
			_vb
			_white
			__TEST_FAILS=$((__TEST_FAILS+1));
		fi
		_vb
	done

	if ! _inSelfTestMode; then tst.report; fi
}

function tst()
{
	local op=$1;
	
	# create delegate fn name.
	local fn_delegate=$(_fn)\.$op;

	if test "$(type -t $fn_delegate)" = "function"; then
		shift;
		_vb "$(_fn): about to delagate and call <$_fn_delegate $@>";
		$fn_delegate "$@";
	else
		_errif "$(_fn): no function called <$fn_delegate> exists $(_bye)";
		exit 1;
	fi
}

_inSelfTestMode
dbg "test mode: $?"
# SELF TEST
if _inSelfTestMode; then

	set -u # TODO

	# "Mock set up and tear down to check they are running correctly"
	function tst.init() 		{ tst.assert --same 1 1; }
	function tst.setup() 		{ tst.assert --diff 222 999; }
	function tst.teardown() 	{ tst.assert --same 100 100; }

	function test.mock_1()		{ tst.assert --same "1" "1"; tst.assert --diff "1" "0"; }
	function test.mock_2()		{ tst.assert --same "1" "0"; tst.assert --diff "0" "0"; }

	_vb
	_vb '######'
	_vb "SELF TEST OPTION SELECTED ON: <$__BU_SRC>"
	_vb
	
	declare -g __SELFTESTOK=true;

	_chkResult()
	{
		if ! test "$1" = "$2"; then 
			_vb "SELF TEST FAILED [<$1> vs <$2>] [SELF-TEST EXPECTS THE TWO VALUES TO BE THE SAME]";
			__SELFTESTOK=false;
		fi
	}

	_doSelfTest()
	{
		tst.run
		tst.report

		_chkResult $__TEST_CNT 2;
		_chkResult $__TEST_PASSES 1;
		_chkResult $__TEST_FAILS 1;
		_chkResult $__ASSERT_PASSES 7
		_chkResult $__ASSERT_FAILS 2

		if $__SELFTESTOK; then 
			_green
			_echoif
			_echoif "nb: it is expected that some tests reported above will fail - this is *part of the self-test*"
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_unsetcolor;
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_echoif
		else
			_echoif
			_red
			_echoif
			_echoif "!!!! FAILURE OF SELF TEST !!! (ASK FOR YOUR MONEY BACK!)";
			_unsetcolor;
			_echoif "!!!! FAILURE OF SELF TEST !!! (ASK FOR YOUR MONEY BACK!)";
		fi
	}

	_doSelfTest 2>&1 | more
	_vb '######'

fi
