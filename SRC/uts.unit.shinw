#!/bin/bash

# TODO: help function.
# TODO: consider:  _vbred, _vbgreen. flags - retionalise, or good enough. 

###
# NB:
# Search 'PUBLIC API' - to find the functions you use to write bash unit-tests.
# all the early code is set up related.
###

# nothing to do if no flag is supplied as first argument to this script directly, or the including script.
__BU_SRC="$0"
__BU_THISFILE="${BASH_SOURCE[0]}";

_dbg()			{ tput setaf 4; echo "$0: $@" >&2; tput setaf 7; }
_exitif()		{ if test $__BU_SRC = $__BU_THISFILE; then exit $1; fi; }

if ! [[ "$1" = -* ]]; then
	_exitif 1;
	return 0;
fi

### IMPORT FROM ENV - OR USE LOCAL DEFAULTS.
# regular expression definition - used find tests (using grep) client code needing testing.
readonly BU_REGEX=${BU_REGEX:-'^.*function.*test.*()'};

### GLOBAL CONSTS.
# self test related.
readonly BU_SELF_TEST_FLAG=${BU_SELF_TEST_FLAG:-'--self'};
readonly BU_VERBOSE_FLAG=${BU_VERBOSE_FLAG-'--selfv'};
readonly BU_SILENT_FLAG=${BU_QUIET_FLAG-'--selfq'};
readonly BU_HELP_FLAG=${BU_HELP_FLAG-'--help'};

# testing bash scripts/functions realted.
readonly BU_TEST_FLAG=${BU_TEST_FLAG:-'--test'};

### SCRIPT GLOBAL VARS ARE PREFIXED WITH __BU
declare -g __BU_FIRST_ARG=${1-}

### START CODE ###

_fn() 			{ local level=${1:-1}; local fn="${FUNCNAME[$level]}"; echo $fn; }
_bye() 			{ _echoif "...terminating - have a wonderful day debugging!"; }

_help()
{
	>&2 echo "WRITE THE HELP SECTION!";
}


# set colors of output, push color to set,and pop to return to previous...
_rmfirst() 		{ shift; echo "$@"; }
_addfirst() 	{ echo "$@"; }
_echofirst() 	{ echo $1; }
_setcolor()  	{ local cmd="tput setaf $1"; $cmd;  } # $cmd >&2;

declare -g __BU_COLSTACK=7 # white.
_pushcolor() 	{ local newcolor=$1; __BU_COLSTACK=$(_addfirst $newcolor $__BU_COLSTACK); _setcolor $newcolor; }
_popcolor()		{ __BU_COLSTACK=$(_rmfirst $__BU_COLSTACK); local previous_color=$(_echofirst $__BU_COLSTACK); _setcolor $previous_color; }

_red() 			{ _pushcolor 1; }
_white() 		{ _pushcolor 7; }
_green() 		{ _pushcolor 2; }
_yellow()		{ _pushcolor 3; }
_blue()			{ _pushcolor 4; }
_unsetcolor()	{ _popcolor; }

# vebose output functions.
declare -g __BU_VERBOSE=1;
_setVerbose() 		{ __BU_VERBOSE=0; _vb 'verbose mode on'; }
_verbose() 			{ return $__BU_VERBOSE; }
_vb() 				{ if _verbose; then _yellow; >&2  _echoif "$@"; _unsetcolor; fi }

# use this function for echo-ing for user output - enables teh output to be switched off.
declare -g __BU_SILENT=1;
_setSilent()	{ __BU_SILENT=0; }
_silent() 		{ return $__BU_SILENT; }

_echoif()		{ if ! _silent; then echo -e "$@"; fi; }
_errif()		{ _echoif "$@" >&2; }

# self test related.
declare -g __BU_SELF_TEST=1;
_setSelfTest() 		{ __BU_SELF_TEST=0; _vb 'self test mode on'; }
_inSelfTestMode() 	{ return $__BU_SELF_TEST; }


### OPTION PARSING ###
# PARSE FOR BASH UNIT RUNTIME OPTIONS
if test "$__BU_FIRST_ARG" = "$BU_SELF_TEST_FLAG"; then
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_VERBOSE_FLAG; then
	_setVerbose;
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_SILENT_FLAG; then
	_setSilent;
	_setSelfTest;
	shift;
elif test "$__BU_FIRST_ARG" = $BU_HELP_FLAG; then
	_errif "help:"
	_errif "-----"
	_help;
	_errif "-----"
	_exitif 1;
	return 1;
fi

#
_vb "self testing $__BU_THISFILE - for help info on the command line run: $__BU_THISFILE --help";

# finding and running unit tests.
_callifdefined() { if test "$(type -t $1)" = "function" ; then "$@"; fi }

_findTests()
{
	local tests=$(grep "$BU_REGEX" $__BU_SRC | grep -v BU_REGEX | sed 's/().*//' | sed 's/function//'; );
    echo $tests
}

declare -g __BU_THIS_TEST_PASSES;

_passFailAssert()
{
	local assertion_success=$1;
	shift 1;

	__BU_ASSERT_COUNT=$((__BU_ASSERT_COUNT+1))

	if $assertion_success; then
		_green
		_vb "assertion passed ("$@")";
		__BU_ASSERT_PASSES=$((__BU_ASSERT_PASSES+1))
		_unsetcolor;
	else 
		_red
		_vb "assertion failed("$@")";
		__BU_ASSERT_FAILS=$((__BU_ASSERT_FAILS+1))
		__BU_THIS_TEST_PASSES=false;
		_unsetcolor;
	fi
}

###### PUBLIC API - THE FOLLOWING FUNCTIONS ARE THOSE INTENDED FOR USE BY CLIENT CODE (USERS OF THIS INCLUDED BASH FILE aka SOURCED SCRIPT)

# IS TESTING MODE ACTIVE?
declare -g 	__BU_TEST_ACTIVE=1;
function tst.active() # returns 0 (true) if testing is active.
{
	return $__BU_TEST_ACTIVE;
}

# ASSERT TWO VALUES ($1, $2) ARE THE SAME
tst.assertSame()
{
	local val1="$1";
	local val2="$2";

	local has_passed=false;

	if test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $has_passed 'tst.assertSame' "<$val1>" "<$val2>"
}

# ASSERT TWO VALUES ($1, $2) ARE DIFFERENT
tst.assertDiff()
{
	local val1=$1;
	local val2=$2;

	local has_passed=false;
	if ! test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $has_passed 'tst.assertDiff' "$@";
}

# WRAPPER FUNCTION FOR ASSERTS - PREFERED FUNCTION TO USE.
function tst.assert() # make an assert during a test. this will be tracked. options: [--same|--diff]
{
	if test "$1" = "--same"; then
		shift;
		tst.assertSame "$@"
	
	elif test "$1" = "--diff"; then
		shift;
		tst.assertDiff "$@"
	
	else
		_errif "$__BU_SRC: no such option: $1 - testing fully aborted";
		_errif
		_exitif 1;
		return 1;
	fi
}

function tst.report() # print a report of test run results.
{
	local status_message="NB: TEST FAILURE(S) FOUND";
	local pass=false;
	
	if test "$__BU_ASSERT_FAILS" = "0"; then 
		status_message="ALL tests_to_run PASSED"; 
		pass=true;	
	fi

	local report="

	Test Report
	-----------
	Total assertions:              $__BU_ASSERT_COUNT
	Assertion_success:             $__BU_ASSERT_PASSES
	Assertion failure:			   $__BU_ASSERT_FAILS
	-----------
	Total tests:                   $__BU_TEST_COUNT
	Test passes:                   $__BU_TEST_PASSES
	Test failures:                 $__BU_TEST_FAILURES
	-----------
	"
	
	_errif "$report"

	if $pass; then _green; else _red; fi
	_errif "($status_message)"
	_unsetcolor;
}

declare -g __BU_ASSERT_COUNT=0
declare -g __BU_ASSERT_PASSES=0
declare -g __BU_ASSERT_FAILS=0

declare -g __BU_TEST_PASSES=0;
declare -g __BU_TEST_FAILURES=0;
declare -g __BU_TEST_COUNT=0;

function tst.run() # run a set of tests.
{
	local tests_to_run=$(_findTests);

	_vb
	_vb "tests to be run: <$tests_to_run>";
	_vb

	_vb "calling if defined: tst.setup"
	_callifdefined tst.init

	for test in $tests_to_run; do
		__BU_TEST_COUNT=$((__BU_TEST_COUNT+1));
		__BU_THIS_TEST_PASSES=true;

		_vb
		_vb "testing: <$test>"

		_vb "calling if defined: tst.setup"
		_callifdefined tst.setup
		_callifdefined $test;
		_vb "calling if defined: tst.teardown"
		_callifdefined tst.teardown

		if $__BU_THIS_TEST_PASSES; then
			_green
			_errif "$test: test passed";
			_white
			__BU_TEST_PASSES=$((__BU_TEST_PASSES+1));
		else
			_red
			_errif "$test: test failed";
			_white
			__BU_TEST_FAILURES=$((__BU_TEST_FAILURES+1));
		fi
		_vb
	done

	if ! _inSelfTestMode; then tst.report; fi
}

function tst()
{
	local op=$1;
	
	# create delegate fn name.
	local fn_delegate=$(_fn)\.$op;

	if test "$(type -t $fn_delegate)" = "function"; then
		shift;
		_vb "$(_fn): about to delagate and call <$_fn_delegate $@>";
		$fn_delegate "$@";
	else
		_errif "$(_fn): no function called <$fn_delegate> exists $(_bye)";
		_exitif 1;
		return 1;
	fi
}

if _inSelfTestMode; then

	# self test in bash 'strict' mode.
	set -u;

	# "Mock set up and tear down to check they are running correctly"
	function tst.init() 		{ tst.assert --same 1 1; }
	function tst.setup() 		{ tst.assert --diff 222 999; }
	function tst.teardown() 	{ tst.assert --same 100 100; }

	function self_test_mock_1()		{ tst.assert --same "1" "1"; tst.assert --diff "1" "0"; }
	function self_test_mock_2()		{ tst.assert --same "1" "0"; _vb "nb: this is expected to fail!"; tst.assert --diff "0" "0"; _vb "nb: this is expected to fail!"; }

	declare -g __BU_SELF_TEST_OK=true;

	_chkResult()
	{
		if ! test "$1" = "$2"; then 
			_vb "SELF TEST FAILED [<$1> vs <$2>] [SELF-TEST EXPECTS THE TWO VALUES TO BE THE SAME]";
			__BU_SELF_TEST_OK=false; 
		fi
	}

	_doSelfTest()
	{
		tst.run
		tst.report

		_chkResult $__BU_TEST_COUNT 	2;
		_chkResult $__BU_TEST_PASSES 	1;
		_chkResult $__BU_TEST_FAILURES 	1;
		_chkResult $__BU_ASSERT_PASSES 	7;
		_chkResult $__BU_ASSERT_FAILS 	2;

		if $__BU_SELF_TEST_OK; then
			_green
			_echoif
			_echoif "nb: it is expected that some tests reported above will fail - this is ---part of the self-test---"
			_echoif "self test passed"
			_echoif "self test passed"
			_unsetcolor;
			_echoif "self test passed"
			_echoif
			_exitif 0;
			return 0;
		else
			_echoif
			_red;
			_echoif "self test FAILED";
			_unsetcolor;
			_echoif "self test FAILED";
			_exitif 1;
			return 1;
	
		fi
	}

	_doSelfTest 2>&1 | more

	_exitif ${PIPESTATUS[0]}
	return ${PIPESTATUS[0]}
fi
