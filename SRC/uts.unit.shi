#!/bin/bash

# TODO: help function.
# TODO: consider:  _vbred, _vbgreen. flags - retionalise, or good enough. 

###
# NB:
# Search 'PUBLIC API' - to find the functions you use to write bash unit-tests.
# all the early code is set up related.
# See the '_help' function (or run this file with --help as the argument) for info
# on how to use this file to unit test scripts or functions in bash.
###

### these functions must be active even if testing is not 'active' - see cmd line flag processing shortly.
# IS TESTING MODE ACTIVE?
declare -g 	__BU_TEST_ACTIVE=1;
function tst.active() # is 'client code' testing active? i.e. test flag on cmd line.
{
	return $__BU_TEST_ACTIVE;
}

# exit this bash include file asap if not required.
readonly __BU_SRC="$0"
readonly __BU_THISFILE="${BASH_SOURCE[0]}";

function tst.exitreturn()
{
	echo "eval if test "$__BU_SRC" = "$__BU_THISFILE"; then exit "$@"; else return "$@"; fi";
}

if ! [[ "$1" = -* ]]; then
	$(tst.exitreturn 0);
fi

_dbg()	{ echo "$(_fn): $@" >&2; }

### IMPORT FROM ENV - OR USE LOCAL DEFAULTS.
# regular expression definition - used find tests (using grep) client code needing testing.
readonly BU_REGEX=${BU_REGEX:-'^.*function.*test.*()'};

### GLOBAL CONSTS. THESE CAN BE OVERRIDEN BY CLIENT CODE WITH ENV VARS.

# self test related.
readonly BU_SELF_TEST_FLAG=${BU_SELF_TEST_FLAG:-'--self'};
readonly BU_SELF_TEST_VERBOSE_FLAG=${BU_SELF_TEST_VERBOSE_FLAG:-'--selfv'};
readonly BU_SELF_TEST_SILENT_FLAG=${BU_SELF_TEST_SILENT_FLAG:-'--selfq'};

# help info.
readonly BU_HELP_FLAG=${BU_HELP_FLAG-'--help'};

# client code test activation.
readonly BU_TEST_FLAG=${BU_TEST_FLAG:-'--test'};
readonly BU_TEST_VERBOSE_FLAG=${BU_TEST_VERBOSE_FLAG:-'--testv'};
readonly BU_TEST_SILENT_FLAG=${BU_TEST_SILENT_FLAG:-'--testq'};


function tst.exitif()	{ if test "$0" = "${BASH_SOURCE[0]}"; then exit $1; fi; } 
# TBB TODO DOCCO.
# TBD. THIS FN DOES NOT WORK IN ANOTHER WHERE THE OTHER IS SOURCED!

### SCRIPT GLOBAL VARS ARE PREFIXED WITH __BU
declare -g __BU_FIRST_ARG=${1-}

### START CODE ###
_fn() 			{ local level=${1:-1}; local fn="${FUNCNAME[$level]}"; echo $fn; }
_bye() 			{ _echoif "...terminating - have a wonderful day debugging!"; }

readonly __BU_HELP_INFO=$(cat <<__BU_ENDOFHELP
	How to use $0. Example:

	--- script.sh ---
	# ...
	
	source path/to/uts.unit.shi
	# ... your code.
	myfunction() { echo 'hello wonderful world'; }	
	# ...
	# ... your code ends.

	# code below this if statement will be parsed by bash only if 'testing is active'
	if ! tst active; then exit 0; fi
		
	function test.myfunction\(\)
	{
		local result=\$(myfunction);
		tst assert --same "\$result" 'hello wonderful world'
		tst assert --diff "\$result" 'goodbye, cruel universe'
	}
	--- end script

	See exmaple files for more information. TODO - URL.

	Functions for use in client tests:

		function tst.assert[] - make an assert during a test. this will be tracked. options: [--same|--diff]
			- e.g. tst assert --diff 1 2

		function tst.active[] - returns bash T/F [0/1] depending if cmd line flags have 'activated testing'
			- e.g. if tst.active; then <do something test related>; fi

		function tst.run[] - run the tests, if the test option has been chosen.
			- e.g. tst active && tst run
			- initiated test running, iff testing has been 'activated'

		call convention:
			- functions should be called  using the 'tst assert' style format [i.e. not dot<.> in the middle - for future compatibility]
			- <tst assert --same \$x "hello world">

	Optional functions:
		- client code defines these; unit test uses them when running tests. if undefined, they are ignored.
		- nb: the dot<.> must be present during function defintion.

		tst.init[] - undefined. define this function and it will be called at the start of testing.
		tst.setup[] - undefined. define this function and it will be called at the start each individual test being run.
		tst.teardown[] - undefined. define this function and it will be called at the end each individual test being run.

	Other function sysnopsis [client code does notuse these]:
		see functions below, important functions are annotated with explanation in commennt # format.

__BU_ENDOFHELP
);

_help()
{
	_blue;
	cat $__BU_ENDOFHELP >&2;
	_white
	exit 0;
}

_isthisfile() { test "$__BU_SRC" = "$__BU_THISFILE"; }

# set colors of output, push color to set,and pop to return to previous...
_rmfirst() 		{ shift; echo "$@"; }
_addfirst() 	{ echo "$@"; }
_echofirst() 	{ echo $1; }
_setcolor()  	{ tput setaf $1; } 

declare -g __BU_COLSTACK=7 # white.
_pushcolor() 	{ local newcolor=$1; __BU_COLSTACK=$(_addfirst $newcolor $__BU_COLSTACK); _setcolor $newcolor; }
_popcolor()		{ __BU_COLSTACK=$(_rmfirst $__BU_COLSTACK); local previous_color=$(_echofirst $__BU_COLSTACK); _setcolor $previous_color; }

_red() 			{ _pushcolor 1; }
_white() 		{ _pushcolor 7; }
_green() 		{ _pushcolor 2; }
_yellow()		{ _pushcolor 3; }
_blue()			{ _pushcolor 4; }
_unsetcolor()	{ _popcolor; }

# vebose output functions.
declare -g __BU_VERBOSE=1;
_setVerbose() 		{ __BU_VERBOSE=0; _vb 'verbose mode on'; }
_verbose() 			{ return $__BU_VERBOSE; }
_vb() 				{ if _verbose; then _yellow; >&2  _echoif "$@"; _unsetcolor; fi }

# use this function for echo-ing for user output - enables the output to be switched off.
declare -g __BU_SILENT=1;
_setSilent()	{ __BU_SILENT=0; }
_silent() 		{ return $__BU_SILENT; }

_echoif()		{ if ! _silent; then echo -e "$@"; fi; }
_errif()		{ _echoif "$@" >&2; }

# self test related.
declare -g __BU_SELF_TEST=1;
_setSelfTest() 		{ __BU_SELF_TEST=0; _vb 'self test mode on'; }
_inSelfTestMode() 	{ return $__BU_SELF_TEST; }

# client test script related.
_setTest() 			{ __BU_TEST_ACTIVE=0; }

### OPTION PARSING ###
# PARSE FOR BASH UNIT RUNTIME OPTIONS
if test "$__BU_FIRST_ARG" = "$BU_SELF_TEST_FLAG"; then
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_SELF_TEST_VERBOSE_FLAG; then
	_setVerbose;
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_SELF_TEST_SILENT_FLAG; then
	_setSilent;
	_setSelfTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_TEST_FLAG; then
	_setTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_TEST_VERBOSE_FLAG; then
	_setVerbose;
	_setTest;
	shift;
elif  test "$__BU_FIRST_ARG" = $BU_TEST_SILENT_FLAG; then
	_setSilent;
	_setTest;
	shift;
elif test "$__BU_FIRST_ARG" = $BU_HELP_FLAG; then
	_errif "help:"
	_errif "-----"
	_help;
	_errif "-----"
	$(tst.exitreturn 0);
fi

# finding and running unit tests.
_callifdefined() { if test "$(type -t $1)" = "function" ; then _vb "calling <$@>"; "$@"; fi }

_findTests()
{
	local tests=$(grep "$BU_REGEX" $__BU_SRC | grep -v BU_REGEX | sed 's/().*//' | sed 's/function//'; );
    echo $tests
}

declare -g __BU_THIS_TEST_PASSES;

_passFailAssert()
{
	local assertion_success=$1;
	shift 1;

	__BU_ASSERT_COUNT=$((__BU_ASSERT_COUNT+1))

	if $assertion_success; then
		_green
		_vb "assertion passed ("$@")";
		__BU_ASSERT_PASSES=$((__BU_ASSERT_PASSES+1))
		_unsetcolor;
	else 
		_red
		_errif "assertion failed("$@")";
		__BU_ASSERT_FAILS=$((__BU_ASSERT_FAILS+1))
		__BU_THIS_TEST_PASSES=false;
		_unsetcolor;
	fi
}

###### PUBLIC API - THE FOLLOWING FUNCTIONS ARE THOSE INTENDED FOR USE BY CLIENT CODE (USERS OF THIS INCLUDED BASH FILE aka SOURCED SCRIPT)

# ASSERT TWO VALUES ($1, $2) ARE THE SAME
tst.assertSame()
{
	local val1="$1";
	local val2="$2";

	local has_passed=false;

	if test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $has_passed 'tst.assertSame' "<$val1>" "<$val2>"
}

# ASSERT TWO VALUES ($1, $2) ARE DIFFERENT
tst.assertDiff()
{
	local val1=$1;
	local val2=$2;

	local has_passed=false;
	if ! test "$val1" = "$val2"; then has_passed=true; fi

	_passFailAssert $has_passed 'tst.assertDiff' "$@";
}

# WRAPPER FUNCTION FOR ASSERTS - PREFERED FUNCTION TO USE.
function tst.assert() # make an assert during a test. this will be tracked. options: [--same|--diff]
{
	if test "$1" = "--same"; then
		shift;
		tst.assertSame "$@"
	
	elif test "$1" = "--diff"; then
		shift;
		tst.assertDiff "$@"
	
	else
		_errif "$__BU_SRC: no such option: $1 - testing fully aborted";
		_errif
		$(tst.exitreturn 1);
	fi
}

function tst.report() # print a report of test run results.
{
	local status_message="NB: TEST FAILURE(S) FOUND";
	local pass=false;
	
	if test "$__BU_ASSERT_FAILS" = "0"; then 
		status_message="ALL TESTS PASSED"; 
		pass=true;	
	fi

	local report="

	Test Report
	-----------
	Total assertions:              $__BU_ASSERT_COUNT
	Assertion success:             $__BU_ASSERT_PASSES
	Assertion fails:               $__BU_ASSERT_FAILS
	-----------
	Total tests:                   $__BU_TEST_COUNT
	Test passes:                   $__BU_TEST_PASSES
	Test failures:                 $__BU_TEST_FAILURES
	-----------
	"
	
	_errif "$report"

	if $pass; then _green; else _red; fi
	_errif "        ($status_message)"
	_errif
	_unsetcolor;
}

declare -g __BU_ASSERT_COUNT=0
declare -g __BU_ASSERT_PASSES=0
declare -g __BU_ASSERT_FAILS=0

declare -g __BU_TEST_PASSES=0;
declare -g __BU_TEST_FAILURES=0;
declare -g __BU_TEST_COUNT=0;

function tst.run() # run a set of tests.
{
	local tests_to_run=$(_findTests);

	_vb "tests to be run: <$tests_to_run>";
	_vb 
	_callifdefined tst.init
	_vb

	for test in $tests_to_run; do
		__BU_TEST_COUNT=$((__BU_TEST_COUNT+1));
		__BU_THIS_TEST_PASSES=true;

		_vb "running test function: <$test>"
		_callifdefined tst.setup
		_callifdefined $test;
		_callifdefined tst.teardown

		if $__BU_THIS_TEST_PASSES; then
			_green
			_errif "$test: test passed";
			_white
			__BU_TEST_PASSES=$((__BU_TEST_PASSES+1));
		else
			_red
			_errif "$test: test failed";
			_white
			__BU_TEST_FAILURES=$((__BU_TEST_FAILURES+1));
		fi
		_vb
	done

	if ! _inSelfTestMode; then tst.report; fi
}

function tst()
{
	local op=$1;
	
	# create delegate fn name.
	local fn_delegate=$(_fn)\.$op;

	if test "$(type -t $fn_delegate)" = "function"; then
		shift;
		# _vb "$(_fn): about to delagate and call <$_fn_delegate $@>";
		$fn_delegate "$@";
	else
		_errif "$(_fn): no function called <$fn_delegate> exists $(_bye)";
		$(tst.exitreturn 1);
	fi
}

if _inSelfTestMode && _isthisfile; then

	# self test in bash 'strict' mode.
	set -u;

	# "Mock set up and tear down to check they are running correctly"
	function tst.init() 		{ tst.assert --same 1 1; }
	function tst.setup() 		{ tst.assert --diff 222 999; }
	function tst.teardown() 	{ tst.assert --same 100 100; }

	function self_test_mock_1()		{ tst.assert --same "1" "1"; tst.assert --diff "1" "0"; }
	function self_test_mock_2()		{ tst.assert --same "1" "0"; _vb "nb: this is expected to fail!"; tst.assert --diff "0" "0"; _vb "nb: this is expected to fail!"; }

	declare -g __BU_SELF_TEST_OK=true;

	_chkResult()
	{
		if ! test "$1" = "$2"; then 
			_vb "SELF TEST FAILED [<$1> vs <$2>] [SELF-TEST EXPECTS THE TWO VALUES TO BE THE SAME]";
			__BU_SELF_TEST_OK=false; 
		fi
	}

	_doSelfTest()
	{
		tst.run
		tst.report

		_chkResult $__BU_TEST_COUNT 	2;
		_chkResult $__BU_TEST_PASSES 	1;
		_chkResult $__BU_TEST_FAILURES 	1;
		_chkResult $__BU_ASSERT_PASSES 	7;
		_chkResult $__BU_ASSERT_FAILS 	2;

		if $__BU_SELF_TEST_OK; then
			_green
			_echoif
			_echoif "nb: it is expected that some tests reported above will fail - it is part of the self-test process"
			_echoif "self test passed"
			_echoif "self test passed"
			_unsetcolor;
			_echoif "self test passed"
			_echoif
			$(tst.exitreturn 0);
		else
			_echoif
			_red;
			_echoif "self test FAILED - as for your money back!";
			_unsetcolor;
			_echoif "self test FAILED";
			$(tst.exitreturn 1);
		fi
	}
	_doSelfTest;
fi
