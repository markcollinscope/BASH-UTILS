#!/bin/bash

###
# NB:
# Search 'PUBLIC API' - to find the functions you use to write bash unit-tests.
# all the early code is setup.
###

### IMPORT FROM ENV - OR USE LOCAL DEFAULTS.
# regular expression definition - used find tests (using grep) client code needing testing.
readonly BASH_UNIT_REGEX=${BASH_UNIT_REGEX:-'^.*function.*test.*()'}

### GLOBAL CONSTS.
# self test related.
readonly __BASHUNIT_SELF_TEST_FLAG="--self"
readonly __BASHUNIT_VERBOSE_FLAG="--selfvb"

# testing bash scripts/functions realted.
readonly __BASHUNIT_TEST_FLAG="--test";

### SCRIPT GLOBAL VARS (BASH: 1 (or any non 0 value) - false, 0 - true - when returned from function).
declare -g __BASHUNIT_FIRST_ARG=${1-}

###
BASH_UNIT_SETUP=${BASH_UNIT_SETUP:-"tst.init"} #### TODO WHY?

__SRC__="$0"

# TODO - WHAT/WHY?
setup=${setup:-"tst.setup"}
teardown=${teardown:-"tst.teardown"}

_fn()
{
	local level=${1:-1};
	local fn="${FUNCNAME[$level]}"

	echo $fn
}

_help()
{
	>&2 echo "WRITE THE HELP SECTION!";
}
_help


# set colors of output, push color to set,and pop to return to previous...
_rmfirst() 		{ shift; echo "$@"; }
_addfirst() 	{ echo "$@"; }
_echofirst() 	{ echo $1; }
_setcolor()  	{ local cmd="tput setaf $1"; $cmd; $cmd >&2; }

declare -g COLSTACK=7
_pushcolor() 	{ local newcolor=$1; COLSTACK=$(_addfirst $newcolor $COLSTACK); _setcolor $newcolor; }
_popcolor()		{ COLSTACK=$(_rmfirst $COLSTACK); local previous_color=$(_echofirst $COLSTACK); _setcolor $previous_color; }

_red() 			{ _pushcolor 1; }
_white() 		{ _pushcolor 7; }
_green() 		{ _pushcolor 2; }
_yellow()		{ _pushcolor 3; }
_unsetcolor()	{ _popcolor; }

# use this function for echo-ing for user output - enables teh output to be switched off.
declare -g __BASHUNIT_SILENT=1;
_silent() 	{ return $__BASHUNIT_SILENT; }
_echoif()	{ if ! _silent; then echo $*; fi; }
_errif()	{ _echoif $* >&2; }

# vebose output functions.
declare -g __BASHUNIT_VERBOSE__=1;
_setVerbose() 		{ __BASHUNIT_VERBOSE__=0; }
_verbose() 			{ return $__BASHUNIT_VERBOSE__; }
_vb() 				{ if _verbose; then _yellow; >&2  _echoif "$@"; _unsetcolor; fi }

# self test related.
declare -g __BASHUNIT_SELFTEST=1;
_setSelfTest() 	{ __BASHUNIT_SELFTEST__=0; }
_selfTest() 	{ return $__BASHUNIT_SELFTEST; }

# PARSE FOR BASH UNIT RUNTIME OPTIONS
if test "$__BASHUNIT_FIRST_ARG" = "$__BASHUNIT_SELF_TEST_FLAG"; then
	_setSelfTest;
	shift;
elif  test "$__BASHUNIT_FIRST_ARG" = $__BASHUNIT_VERBOSE_FLAG; then
	_setVerbose;
	_setSelfTest;
	shift;
elif [[ $__BASHUNIT_FIRST_ARG == -* ]]; then
	_errif "$0: help:"
	_help;
	_errif "$0: terminating... have a wickedly awesome day!"
	exit 1;
fi

set -u # TODO

# finding and running unit tests.
_callifdefined() { if test "$(type -t $1)" = "function" ; then "$@"; fi }

_findTests()
{
	local tests=$(grep "$BASH_UNIT_REGEX" $__SRC__ | grep -v BASH_UNIT_REGEX | sed 's/().*//' | sed 's/function//'; );
    echo $tests
}

_passFailAssert()
{
	local testfn=$1;
	local ASSERTION_SUCCESS=$2;
	shift 2;

	_ASSERT_COUNT=$((_ASSERT_COUNT+1))

	if $ASSERTION_SUCCESS; then
		_green
		_vb "$testfn -- Assertion Passed ("$@")";
		_ASSERT_PASSES=$((_ASSERT_PASSES+1))
		_unsetcolor;
	else 
		_red
		_vb "$testfn -- Assertion Failed("$@")";
		_ASSERT_FAILS=$((_ASSERT_FAILS+1))
		_THIS_TEST_PASSES=false;
		_unsetcolor;
	fi
}

###### PUBLIC API - THE FOLLOWING FUNCTIONS ARE THOSE INTENDED FOR USE BY CLIENT CODE (USERS OF THIS FILE)

# IS TESTING MODE ACTIVE?
declare -g 	__BASHUNIT_TEST_ACTIVE=1;
function tst.active()
{
	return $__BASHUNIT_TEST_ACTIVE;
}

# ASSERT TWO VALUES ($1, $2) ARE THE SAME
function tst.assertSame()
{
	local testfn=$1;
	local VAL1="$2";
	local VAL2="$3";

	local HAS_PASSED=false;

	if test "$VAL1" = "$VAL2"; then HAS_PASSED=true; fi

	_passFailAssert $testfn $HAS_PASSED tst.assertSame "<$VAL1>" "<$VAL2>"
}

# ASSERT TWO VALUES ($1, $2) ARE DIFFERENT
function tst.assertDiff()
{
	local testfn=$1;
	local VAL1=$2;
	local VAL2=$3;

	local HAS_PASSED=false;
	if ! test "$VAL1" = "$VAL2"; then HAS_PASSED=true; fi

	_passFailAssert $testfn $HAS_PASSED tst.assertDiff "$@";
}

# WRAPPER FUNCTION FOR ASSERTS - PREFERED FUNCTION TO USE.
function tst.assert()
{
	local fn=$(_fn 4);

	if test "$1" = "--same"; then
		shift;
		tst.assertSame $fn "$@"
	
	elif test "$1" = "--diff"; then
		shift;
		tst.assertDiff $fn "$@"
	
	elif test "$1" = "--true"; then
		shift;
		tst.assertSame $fn true "$@"
	
	elif test "$1" = "--false"; then
		shift;
		tst.assertSame $fn false "$@"
	
	elif test "$1" = "--ok"; then
		shift;
		tst.assertSame $fn 0 "$@";

	elif test "$1" = "--err"; then
		shift;
		tst.assertDiff $fn 0 "$@";
	
	else
		_errif
		_errif "$0: no such option: $1 - testing fully aborted";
		_errif
		exit 1;
	fi
}

function tst.report()
{
	local STATUS_MESSAGE="NB: TEST FAILURE(S) FOUND";
	local pass=false;
	
	if test "$_ASSERT_FAILS" = "0"; then 
		STATUS_MESSAGE="ALL TESTS PASSED"; 
		pass=true;	
	fi

	cat <<ENDCAT

	Test Report
	-----------
	TOTAL ASSERTIONS:              $_ASSERT_COUNT
	ASSERTION_SUCCESS:             $_ASSERT_PASSES
	ASSERTION FAILURES:            $_ASSERT_FAILS
	-----------
	TOTAL TESTS:                   $_TEST_CNT
	TEST PASSES:                   $_TEST_PASSES
	TEST FAILURES:                 $_TEST_FAILS
	-----------
ENDCAT

	if $pass; then _green; else _red; fi

cat <<ENDCAT

	($STATUS_MESSAGE)

ENDCAT
	_unsetcolor;
}

declare -g _ASSERT_COUNT=0
declare -g _ASSERT_PASSES=0
declare -g _ASSERT_FAILS=0

declare -g _TEST_PASSES=0;
declare -g _TEST_FAILS=0;
declare -g _TEST_CNT=0;

function tst.run()
{
	local TESTS=$(_findTests);

	_vb
	_vb "ABOUT TO RUN THE FOLLOWING TESTS: <$TESTS>";
	_vb

	_callifdefined $BASH_UNIT_SETUP;

	for test in $TESTS; do
		_TEST_CNT=$((_TEST_CNT+1));
		_THIS_TEST_PASSES=true;

		_vb
		_vb "TESTING FUNCTION <$test>"

		_callifdefined $setup;
		_callifdefined $test;
		_callifdefined $teardown

		_vb
		if $_THIS_TEST_PASSES; then
			_green
			_vb "**** $test -- Test Passed ****";
			_vb
			_white
			_TEST_PASSES=$((_TEST_PASSES+1));
		else
			_red
			_vb "**** $test -- Test Failed ****";
			_vb
			_white
			_TEST_FAILS=$((_TEST_FAILS+1));
		fi
		_vb
	done

	if ! _selfTest; then tst.report; fi
}



# SELF TEST
if _selfTest; then

	# "Mock setup and tear down to check they are running correctly"
	function tst.init() 		{ tst.assert --same 1 1; }
	function tst.setup() 		{ tst.assert --diff 222 999; }
	function tst.teardown() 	{ tst.assert --same 100 100; }

	function test.mock_1()		{ tst.assert --same "1" "1"; tst.assert --diff "1" "0"; }
	function test.mock_2()		{ tst.assert --same "1" "0"; tst.assert --diff "0" "0"; }

	_vb
	_vb '######'
	_vb "SELF TEST OPTION SELECTED ON: <$__SRC__>"
	_vb
	
	_SELFTESTOK=true;

	_chkResult()
	{
		if ! test "$1" = "$2"; then 
			_vb "SELF TEST FAILED [<$1> vs <$2>] [SELF-TEST EXPECTS THE TWO VALUES TO BE THE SAME]";
			_SELFTESTOK=false;
		fi
	}

	_doSelfTest()
	{
		tst.run
		tst.report

		_chkResult $_TEST_CNT 2;
		_chkResult $_TEST_PASSES 1;
		_chkResult $_TEST_FAILS 1;
		_chkResult $_ASSERT_PASSES 7
		_chkResult $_ASSERT_FAILS 2

		if $_SELFTESTOK; then 
			_green
			_echoif
			_echoif "nb: it is expected that some tests reported above will fail - this is *part of the self-test*"
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_unsetcolor;
			_echoif "*** SELF TEST PASSED *** *** SELF TEST PASSED *** *** SELF TEST PASSED ***"
			_echoif
		else
			_echoif
			_red
			_echoif
			_echoif "!!!! FAILURE OF SELF TEST !!! (ASK FOR YOUR MONEY BACK!)";
			_unsetcolor;
			_echoif "!!!! FAILURE OF SELF TEST !!! (ASK FOR YOUR MONEY BACK!)";
		fi
	}

	_doSelfTest 2>&1 | more
	_vb '######'

fi
