ADTs - Standard Functions

list (eg)
	.encode - encode to one val format. tagged, coded. [ VAL ]
	.decode - returns 'echo' version of type. One level only. No element decoding. [ VAL ]
	.val - return 1value. [VAL] [ TypeTagged ]
	.echo - return 'standard' raw format. (or .raw?) [VAL REF ?] -- same as init format? recursive down?
	.init - ctor - called to create thing [VAL REF ALL] - multiple implementations determined internally - to start with.
		fn() { local l=$(list init "$@"); }
	.new - args as  per .init - returns a 'new' reference to type. [ REF ]
		fn() { local -n rl=$(list new "$@"); }
	.ref - (list ref rl ...) - rl - ref var. 'init' using rl as target. args: 
		.init args - to create a new one. in rmap format? [No: you'd use 'new' for that.] so: as ref arg (local usage)
		fn() { local -n rl=$(ref list $1). } => even for cascading down fn calls as arg.
		.val style arg - creates a 


	ITER
	.each - apply fn to each element, replacing existing elements with result [ITER]
	.map - (startval, fn) - apply fn over .each using startval. fn of form fn(runningval, element). [ITER] - echo returns a 1value.

list
	1) <default action> - validate and return as per .val. [VAL]
	2) <default action> - validate initialise (local) ref [REF]

	e.g. fn() {
		1) local l=$(val list $1); # VAL.
		2) local -n rl=$(ref list $1) # REF
		# Q: two fns, or one?
	}

semver (eg)
	.val (as per .echo)
	.echo - well formed semver.
	.init ma mi pa 
	<could have ref i/f version...>

BASE REF
ref
	<default> $1 - is $1 a ref? return $1.
	.new
	.del
local -n rv=ref.new() { create an anon var, return its name; }
ref.del(rv) { delete the anon var contents; }

local -n rl=$(ref list $1);

BASE VAL
val
	<default> - is there anything there? check its 'not' a ref. ereturn value.
