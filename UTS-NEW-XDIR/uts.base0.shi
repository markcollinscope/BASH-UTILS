#!/bin/bash

source uts.global.shi;
$(uts.return_if_read);

uts.out() { printf "$@"; }

uts.err() { >&2 uts.out "$@"; }
uts.yield() { uts.out $*; }
uts.null() { test -z "$*"; }

uts.stack() 
{ 
	local cnt=1;  
	while ! test -z ${FUNCNAME[$cnt]}; do 
		uts.yield "%s..." ${FUNCNAME[$cnt]}; 
		cnt=$((cnt + 1)); 
	done; 
}

uts.script() {  uts.yield $(basename $0); }; 	

uts.abort()
{
	local exitcode=${1:-1};
	uts.err "terminating <$(uts.script)> with exit code %d\n" $exitcode;
	uts.err "stack trace: %s" $(uts.stack);
    exit $exitcode;
}

uts.nout() { >/dev/null "$@";  }		
uts.nerr() { 2>/dev/null "$@"; }	
uts.none() { uts.no uts.ne "$@"; }

uts.thisfile() { uts.yield ${BASH_SOURCE[0]}; }

uts.fn() { local level=${1-0}; uts.yield ${FUNCNAME[$level]}; }
uts.thisfn() { uts.fn 2; }

uts.callingfn() { uts.fn 3; } 
# uts.yield ${FUNCNAME[2]}; TODO.

uts.whitepace() { local in="$@"; local sedval=$(sed 's/ //' <<< $in); ! test "$in" = "$sedval"; }

uts.isval() { ! uts.null "$@"; }

uts.isref()
{
	local ref=$(uts.val $1);
	uts.none declare -p $ref
}

uts.isint()
{
	local val=$(uts.val $1);
	local intregx="^[0-9]*$"	
	local sedval=$(sed "s/$intregx//" <<< $val);
	! test $val = "$sedval";
}

uts.ab() { uts.yield "<$@>"; }

# mv to global no prefix functions.
null() { uts.null "$@"; }
ne() { uts.nerr "$@"; }
no() { uts.nout "$@"; }
none() { uts.none "$@"; }
ab() { uts.ab "$@"; }		# $(ab words) => '<words>' - in (a)ngle (b)rackets... ab...
ws() { uts.whitespace "$@"; }

