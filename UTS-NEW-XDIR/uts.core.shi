#!/bin/bash

source uts.uts.shi;

$(uts.return_if_already_processed);

uts.out()
{
	printf "$@";
}

uts.err()
{
	>&2 uts.out "$@";
}

uts.stack() { local cnt=1;  while ! test -z ${FUNCNAME[$cnt]}; do uts.yield "%s..." ${FUNCNAME[$cnt]}; cnt=$((cnt + 1)); done; }

uts.null() { if test -z "$*"; then return 0; else return 1; fi }; 

uts.script() 
{ 
    if ! uts.null $0; then
	    uts.yield $(basename $0);
    else 
        uts.yield "bash-cmd-line";
    fi
}; 	

uts.abort()
{
	local exitcode=${1:-1};
	uts.err "terminating with error code %d\n" $exitcode;
	uts.err "stack trace: %s" $(uts.stack);
    exit $exitcode;
}

uts.nerr() 
{ 
	2>/dev/null "$@"; 
}	

uts.nout() 
{ 
	>/dev/null "$@"; 
}		
 
uts.none()
{
	uts.no uts.ne "$@";
}

uts.yield()
{
	uts.out $*;
}

uts.thisfile() { uts.yield ${BASH_SOURCE[0]}; }

uts.fn()
{
	local level=${1-1};
	uts.yield ${FUNCNAME[$level]};
}

uts.caller()
{
	uts.yield ${FUNCNAME[2]}
}

uts.lineno()
{
	:; # TBD.
}

uts.val()
{
	local val=$1
	local caller=$(uts.caller);
	uts.null $val && uts.err "$(uts.caller): null value passed to <$(uts.fn)>\n" && uts.abort;

	uts.yield $val;
}

uts.val 

null() { uts.null $*; } # mv to global no prefix functions.

