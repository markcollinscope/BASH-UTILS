#!/bin/bash

source uts.uts.shi
$(uts.once)

if true; then

sd.rm()
{
	local rmval=$(val $1); shift;
	local target=$(vals "$@")
	sed "s/$rmval//g" <<< $target
}

sd.in()
{
    local val=$(val $1); shift;
    local target=$(vals "$@");

	local rmtarget=$(sd.rm $val $target);
	! test "$rmtarget" = "$target"
}

uts.in()
{
    local val=$(val $1);
    shift;
    local vals=$(vals "$@");

	# optimise
    for i in $vals; do
        if test $i = $val; then
            return 0;
        fi
    done
    return 1;
}

int()
{
	echo $*;
}

uts.mkfn()
{
	local prefix=$(val $;)
}


uts.err()
{
    uts.out --channel 2 $*;
}

uts.yield()
{
    echo $*;
}

rxcode()
{
	# int < 256;
	echo $*;
}



assert()
{
    eval "$@";
    ! $? && {
		uts.err "assert fail (assering <$@>)call stack: <${FUNCNAME[1]}> <${FUNCNAME[2]}> <${FUNCNAME[3]}>"; 
        uts.abort;
    }
}

word()
{
	echo 'what?'
}

val() 
{ 
    assert ! null "$@"; 
    uts.yield $*; 
}

vals() 
{ 
    assert ! null "$@"; 
    uts.yield $*; 
}

enum()
{
    local name=$(val $1);
    shift;
    local values=$(vals "$@");
}

uts.null()
{
    test -z "$@";
}

null() { uts.null "$@"; }

opt.is()
{
    local opt=$(val $1);
    local cmp=$(val $2);
    test $opt = $cmp;
}

fi

enum.assert()
{
	local val=$(val $1); shift;
    local enumvals=$(vals "$@");

    assert uts.in $val $enumvals;
}

bool.is()
{
    local val=$(bool $1);
    uts.in $val $(bool);
}

bool.from()
{
    local bval=$(bool $1);
    test $bval && return true;
    return false;
}

bool.as()
{
    local bval=$(bool $1);
    test $bval = "true";
}

bool.enum()
{
	uts.yield "true false";
}

bool.init()
{
	local v=$(val $1);
	if $(rxcode.is $v); then
		if $((v == 0)); then v=true; else v=false; fi
	fi
	enum.assert $v $(bool.enum);
}

bool()
{
	local op=$(val $1)
	# ... process other fns.
	local bval=$(val $1);
	enum.assert $(bool.enum);
	uts.yield $bval;
}

